
# MongoDB Atlas Integration Guide

## Overview
This document provides detailed instructions on how to integrate MongoDB Atlas with our application. MongoDB Atlas is a fully-managed cloud database service that handles all the complexity of deploying, managing, and healing deployments on the cloud service provider of your choice.

## Why MongoDB Atlas?
- **Schema Flexibility**: No need to define strict schemas upfront - MongoDB adapts to your data structure
- **Cloud-Native**: Fully managed service with automated backups, scaling, and security
- **Developer-Friendly**: Intuitive interface and robust documentation
- **Performance**: Optimized for high performance with built-in sharding and indexing

## Step 1: Setting Up MongoDB Atlas

1. **Create an Atlas Account**:
   - Go to [MongoDB Atlas](https://www.mongodb.com/cloud/atlas)
   - Sign up for a free account

2. **Create a Cluster**:
   - Click "Build a Cluster"
   - Choose your preferred cloud provider (AWS, Google Cloud, or Azure)
   - Select a region close to your users
   - Choose cluster tier (Free tier available for development)
   - Name your cluster (e.g., "fintrack-db")

3. **Set Up Database Access**:
   - Create a database user with password authentication
   - Give appropriate permissions (readWrite to specific databases)
   - Example: 
     ```
     Username: fintrack-app
     Password: [secure-password]
     User Privileges: readWrite on fintrack-db
     ```

4. **Configure Network Access**:
   - Add IP addresses that can connect to your cluster
   - For development, you can allow access from anywhere (0.0.0.0/0)
   - For production, restrict to specific IP addresses or ranges

## Step 2: Connecting Your Application

1. **Install Dependencies**:
   ```bash
   npm install mongodb
   ```

2. **Create Connection File**:
   ```javascript
   // src/db/mongo.js
   const { MongoClient } = require('mongodb');
   require('dotenv').config();

   const uri = process.env.MONGODB_URI;
   const client = new MongoClient(uri, {
     useNewUrlParser: true,
     useUnifiedTopology: true,
   });

   let dbConnection;

   module.exports = {
     connectToDb: async () => {
       try {
         const connection = await client.connect();
         dbConnection = connection.db('fintrack-db');
         console.log('Connected to MongoDB Atlas');
         return dbConnection;
       } catch (error) {
         console.error('Failed to connect to MongoDB', error);
         throw error;
       }
     },
     getDb: () => dbConnection,
   };
   ```

3. **Environment Setup**:
   Create a `.env` file in the root directory:
   ```
   MONGODB_URI=mongodb+srv://username:password@cluster.mongodb.net/fintrack-db?retryWrites=true&w=majority
   ```
   (Replace with your actual connection string from Atlas dashboard)

## Step 3: Data Schema Design

While MongoDB is schema-less, it's good practice to define schemas for your application:

### User Schema
```javascript
// Example user document structure
{
  _id: ObjectId,
  name: String,
  imageUrl: String,
  preferences: {
    showDebtFeature: Boolean,
    showAllAccountsAnalysis: Boolean,
    currency: String
  },
  createdAt: Date,
  updatedAt: Date
}
```

### Account Schema
```javascript
// Example account document structure
{
  _id: ObjectId,
  userId: ObjectId,
  name: String,
  isActive: Boolean,
  createdAt: Date,
  updatedAt: Date
}
```

### Transaction Schema
```javascript
// Example transaction document structure
{
  _id: ObjectId,
  accountId: ObjectId,
  userId: ObjectId,
  date: Date,
  investment: Number,
  earnings: Number,
  spending: Number,
  toBeCredit: Number,
  salary: Number,
  debt: Number,
  interestRate: Number,
  salaryEntries: [
    {
      name: String,
      purpose: String,
      amount: Number,
      date: Date
    }
  ],
  createdAt: Date,
  updatedAt: Date
}
```

## Step 4: Implementation of CRUD Operations

### Create Operations
```javascript
// Example: Create a new transaction
async function createTransaction(transaction) {
  const db = getDb();
  const result = await db.collection('transactions').insertOne({
    ...transaction,
    createdAt: new Date(),
    updatedAt: new Date()
  });
  return result;
}
```

### Read Operations
```javascript
// Example: Get all transactions for an account
async function getAccountTransactions(accountId) {
  const db = getDb();
  const transactions = await db.collection('transactions')
    .find({ accountId: accountId })
    .sort({ date: -1 })
    .toArray();
  return transactions;
}
```

### Update Operations
```javascript
// Example: Update a transaction
async function updateTransaction(id, updatedData) {
  const db = getDb();
  const result = await db.collection('transactions').updateOne(
    { _id: new ObjectId(id) },
    { 
      $set: {
        ...updatedData,
        updatedAt: new Date()
      }
    }
  );
  return result;
}
```

### Delete Operations
```javascript
// Example: Delete a transaction
async function deleteTransaction(id) {
  const db = getDb();
  const result = await db.collection('transactions').deleteOne(
    { _id: new ObjectId(id) }
  );
  return result;
}
```

## Step 5: Migration from LocalStorage to MongoDB

When you're ready to migrate from localStorage to MongoDB:

1. **Create a migration script**:
   ```javascript
   async function migrateLocalStorageToMongo() {
     // Get data from localStorage
     const accounts = JSON.parse(localStorage.getItem('user_accounts') || '[]');
     const transactions = JSON.parse(localStorage.getItem('finance_transactions') || '{}');
     const userProfile = JSON.parse(localStorage.getItem('user_profile') || '{}');
     
     const db = getDb();
     
     // Migrate user profile
     const user = await db.collection('users').insertOne({
       name: userProfile.name || 'Default User',
       imageUrl: userProfile.imageUrl || '',
       preferences: {
         showDebtFeature: userProfile.showDebtFeature || false,
         showAllAccountsAnalysis: userProfile.showAllAccountsAnalysis || false
       },
       createdAt: new Date(),
       updatedAt: new Date()
     });
     
     const userId = user.insertedId;
     
     // Migrate accounts
     const accountPromises = accounts.map(async (account) => {
       const result = await db.collection('accounts').insertOne({
         userId,
         name: account.name,
         isActive: account.isActive,
         createdAt: new Date(),
         updatedAt: new Date()
       });
       return { oldId: account.id, newId: result.insertedId };
     });
     
     const accountMap = await Promise.all(accountPromises);
     
     // Migrate transactions
     for (const [accId, accTransactions] of Object.entries(transactions)) {
       const account = accountMap.find(a => a.oldId === accId);
       if (account) {
         for (const transaction of accTransactions) {
           await db.collection('transactions').insertOne({
             accountId: account.newId,
             userId,
             date: new Date(transaction.date),
             investment: Number(transaction.investment || 0),
             earnings: Number(transaction.earnings || 0),
             spending: Number(transaction.spending || 0),
             toBeCredit: Number(transaction.toBeCredit || 0),
             salary: Number(transaction.salary || 0),
             debt: Number(transaction.debt || 0),
             interestRate: Number(transaction.interestRate || 0),
             salaryEntries: transaction.salaryEntries || [],
             createdAt: new Date(),
             updatedAt: new Date()
           });
         }
       }
     }
     
     console.log('Migration completed successfully');
   }
   ```

2. **Transition Strategy**:
   - First, implement a dual-write approach (write to both localStorage and MongoDB)
   - Then, implement a read-from-MongoDB, fallback-to-localStorage strategy
   - Finally, once confident in MongoDB implementation, remove localStorage usage

## Step 6: Security Best Practices

1. **Store Connection String in Environment Variables**
   - Never hardcode your MongoDB connection string
   - Use a package like dotenv to manage environment variables

2. **Implement Proper Authentication**
   - Use MongoDB Atlas built-in authentication
   - Consider implementing JWT for user authentication in your app

3. **Data Validation**
   - Even though MongoDB is schema-less, validate data before inserting
   - Consider using a library like Joi for validation

4. **Index Your Collections**
   - Create appropriate indexes for frequently queried fields
   - Example: 
     ```javascript
     db.collection('transactions').createIndex({ accountId: 1, date: -1 })
     ```

5. **Handle Errors Properly**
   - Implement proper error handling for database operations
   - Log errors with enough context for debugging

## Step 7: Advanced Features

Once your base MongoDB integration is working, consider these advanced features:

1. **Aggregation Pipeline** for analytics
2. **Change Streams** for real-time updates
3. **MongoDB Atlas Search** for full-text search capabilities
4. **MongoDB Atlas Charts** for data visualization

## Conclusion

MongoDB Atlas provides a powerful, flexible database solution that scales with your application. By following these instructions, you'll be able to integrate MongoDB Atlas with your application and leverage its features for improved data management and user experience.
